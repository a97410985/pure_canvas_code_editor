<!-- 能夠調整畫布大小，以及增加dark_mode -->
<!-- 先增加兩個按鈕，一個按下會變寬、一個按下會變窄，來測試畫布變化 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>editor_v12</title>

    <style>
        .editor-non-focus {
            border: black 1px solid;
        }

        .editor-focus {
            border: #ff7f11 1px solid;
        }

        /*  滑桿ui的部分  */
        .slider {
            position: relative;
            top: -4px;
            margin: 0;
            -webkit-appearance: none;
            width: 500px;
            height: 25px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        .v-slider {
            margin: 0;
            -webkit-appearance: none;
            width: 500px;
            height: 25px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        .slider:hover, .v-slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb, .v-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 50px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
        }

        .v-slider {
            position: absolute;
            top: 238px;
            left: 262px;
            transform: rotate(90deg);
        }

    </style>
    <style data="slider" type="text/css"></style>
</head>
<body>
<div id="canvas-text-editor" style="position:relative;width: fit-content">
    <div>
        <textarea id="textInput" style="position: absolute; z-index:-1;"></textarea>
        <canvas id="canvas" width="500" height="500"></canvas>
        <input type="range" min="0" max="100" value="0" class="v-slider" style="display: inline-block;">
    </div>
    <input type="range" min="0" max="100" value="0" class="slider">
</div>
<!-- todo:按鈕 -->
<button id="increase-btn">讓畫布變寬</button>

<!-- source: https://github.com/jondavidjohn/hidpi-canvas-polyfill 將高畫質圖像縮小來達成高畫質繪製，解決字體模糊的問題 -->
<script src="lib/hidpi-canvas.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
<script>
    WebFont.load({
        google: {
            families: ['Courier New']
        }
    });
</script>
<script>
    /**
     * A simple wrapper for system fonts to provide
     * @param {String} family Font Family (same as in CSS)
     * @param {Number} size Size in px
     * @constructor
     */
    var FontMetrics = function (family, size) {
        this._family = family || (family = "Courier New, Courier, monospace");
        this._size = parseInt(size) || (size = 12);

        // Preparing container
        var line = document.createElement('div'),
            body = document.body;
        line.style.position = 'absolute';
        line.style.whiteSpace = 'nowrap';
        line.style.font = size + 'px ' + family;
        body.appendChild(line);

        // Now we can measure width and height of the letter
        var text = 'mmmmmmmmmm';
        line.innerHTML = text;
        this._width = line.offsetWidth / text.length;
        this._height = line.offsetHeight;

        // Now creating 1px sized item that will be aligned to baseline
        // to calculate baseline shift
        var span = document.createElement('span');
        span.style.display = 'inline-block';
        span.style.overflow = 'hidden';
        span.style.width = '1px';
        span.style.height = '1px';
        line.appendChild(span);

        // Baseline is important for positioning text on canvas
        this._baseline = span.offsetTop + span.offsetHeight;
        line.remove();
    };


    /**
     * Returns font family
     * @return {String}
     */
    FontMetrics.prototype.getFamily = function () {
        return this._family;
    };

    /**
     * Returns font family
     * @return {Number}
     */
    FontMetrics.prototype.getSize = function () {
        return this._size;
    };

    /**
     * Returns line height in px
     * @return {Number}
     */
    FontMetrics.prototype.getHeight = function () {
        return this._height;
    };

    /**
     * Returns line height in px
     * @return {Number}
     */
    FontMetrics.prototype.getWidth = function () {
        return this._width;
    };

    /**
     * Returns line height in px
     * @return {Number}
     */
    FontMetrics.prototype.getBaseline = function () {
        return this._baseline;
    };
</script>

<script>
    var Selection = function (editor) {
        this.editor = editor;
        this.textInputDom = document.getElementById('textInput');
        this.start = {
            line: 0,
            ch: 0
        }
        this.end = {
            line: 0,
            ch: 0
        }
        this.blinkInterval = 500;
        this.caretDiv = document.createElement('div');
        this.caretDiv.style.position = 'absolute';
        this.caretDiv.style.width = '1px';
        this.caretDiv.style.height = this.editor.getFontMetric().getHeight() + 'px';
        this.caretDiv.style.background = 'black';
        this.editor.getEl().appendChild(this.caretDiv);
        this.blink = function () {
            if (this.caretDiv.style.opacity === '1') {
                this.caretDiv.style.opacity = '0';
            } else {
                this.caretDiv.style.opacity = '1';
            }
        }
    }
    Selection.prototype.getStart = function () {
        return this.start;
    }
    Selection.prototype.getEnd = function () {
        return this.end;
    }
    let canvas = document.getElementById('canvas');
    let editor_vScrollBar = document.querySelector('#canvas-text-editor>div>input[type=range]');
    let editor_hScrollBar = document.querySelector('#canvas-text-editor>input[type=range]');
    // caret可能超出邊界
    Selection.prototype.updateCursor = function (line, ch) {
        // 因為一個tab佔四個空格，所以caret位置的計算比較特別
        let lineContent = this.editor.editorContent[line];
        let tabNum = 0;
        let offset = this.editor.getOffset();
        for (let i = 0; i < ch; i++) {
            if (lineContent[i] === '\t') {
                tabNum += 1;
            }
        }
        let contentWid = this.editor.fontMetric.getWidth() * (ch - tabNum) + this.editor.fontMetric.getWidth() * 4 * tabNum;
        this.caretDiv.style.left = (this.editor.canvas.offsetLeft + contentWid + 1 + offset.left).toString() + 'px';
        this.caretDiv.style.top = (this.editor.canvas.offsetTop + line * this.editor.getFontMetric().getHeight() + offset.top).toString() + 'px';
        if (this.editor.focus) {
            this.caretDiv.style.opacity = '1';
            clearInterval(this.interval);
            this.interval = setInterval(this.blink.bind(this), this.blinkInterval);
        } else {
            this.caretDiv.style.opacity = '0';
        }
    }

    Selection.prototype.addChs = function (num) {
        this.start.ch += num;
        this.end.ch += num;
        this.updateCursor(this.start.line, this.start.ch);
    }
    Selection.prototype.setStartPos = function (line, ch) {
        this.start.line = line;
        this.start.ch = ch;
    }
    Selection.prototype.setEndPos = function (line, ch) {
        this.end.line = line;
        this.end.ch = ch;
    }
    Selection.prototype.setPosition = function (line, ch) {
        this.setStartPos(line, ch);
        this.setEndPos(line, ch);
        this.updateCursor(line, ch);
    }
    Selection.prototype.moveLeft = function () {
        // 要先清除目前選取的東西
        let curCh = this.end.ch;
        let curLine = this.end.line;
        if (curCh > 0) {
            curCh--;
        } else {
            if (curLine > 0) {
                curLine--;
                curCh = this.editor.editorContent[curLine].length;
            }
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.moveRight = function () {
        let curCh = this.end.ch;
        let curLine = this.end.line;
        let curLineStr = this.editor.editorContent[curLine];
        if (curCh > curLineStr.length - 1) {
            if (curLine < this.editor.editorContent.length - 1) {
                curLine++;
                curCh = 0;
            }
        } else {
            curCh++;
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.moveUp = function () {
        let curCh = this.end.ch;
        let curLine = this.end.line;
        if (curLine > 0) {
            curLine--;
            let curLineStr = this.editor.editorContent[curLine];
            if (curCh > curLineStr.length) {
                curCh = curLineStr.length;
            }
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.moveDown = function () {
        let curCh = this.end.ch;
        let curLine = this.end.line;
        if (curLine < this.editor.editorContent.length - 1) {
            curLine++;
            let curLineStr = this.editor.editorContent[curLine];
            if (curCh > curLineStr.length) {
                curCh = curLineStr.length;
            }
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.selectLeft = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveLeft();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.selectRight = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveRight();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.selectUp = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveUp();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.selectDown = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveDown();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.deleteSelection = function () {
        if (this.start.line === this.end.line) {
            let content = this.editor.editorContent[this.start.line];
            let left = Math.min(this.start.ch, this.end.ch);
            let right = Math.max(this.start.ch, this.end.ch);
            this.editor.editorContent[this.start.line] = content.substr(0, left) + content.substr(right, content.length - right);
            this.setPosition(this.start.line, left);
            // 送出通知
            this.editor.updateEditorContentStyle(this.editor.EditNotifyType.CHANGE, {
                sLine: this.start.line,
                eLine: this.end.line
            });
        } else {
            // 一定有一行在比較下面，我叫他downRightStr
            let downRightStr = '';
            let startLineStr = this.editor.editorContent[this.start.line];
            let endLineStr = this.editor.editorContent[this.end.line];

            if (this.start.line < this.end.line) {
                downRightStr = endLineStr.substr(this.end.ch, endLineStr.length - this.end.ch);
                this.editor.editorContent.splice(this.start.line + 1, this.end.line - this.start.line);
                this.editor.editorContent[this.start.line] = startLineStr.substr(0, this.start.ch) + downRightStr;
                // 送出通知
                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.DELETE, {
                    sLine: this.start.line + 1,
                    eLine: this.end.line
                });

                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.CHANGE, {
                    sLine: this.start.line,
                    eLine: this.start.line
                });
                this.setPosition(this.start.line, this.start.ch);
            } else {
                downRightStr = startLineStr.substr(this.start.ch, startLineStr.length - this.start.ch);
                this.editor.editorContent.splice(this.end.line + 1, this.start.line - this.end.line);
                this.editor.editorContent[this.end.line] = endLineStr.substr(0, this.end.ch) + downRightStr;
                // 送出通知
                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.DELETE, {
                    sLine: this.end.line + 1,
                    eLine: this.start.line
                });

                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.CHANGE, {
                    sLine: this.end.line,
                    eLine: this.end.line
                });
                this.setPosition(this.end.line, this.end.ch);
            }

        }
    }
    Selection.prototype.isSelection = function () {
        return !(this.start.line === this.end.line && this.start.ch === this.end.ch);
    }
    Selection.prototype.copySelection = function () {
        let copyStr = '';
        if (this.start.line === this.end.line) {
            let min = Math.min(this.start.ch, this.end.ch);
            let max = Math.max(this.start.ch, this.end.ch);
            copyStr = this.editor.editorContent[this.start.line].substr(min, max - min);
        } else {
            let upLine = 0;
            let downLine = 0;
            let upLineRightStr = '';
            let downLineLeftStr = '';
            if (this.start.line < this.end.line) {
                upLine = this.start.line;
                downLine = this.end.line;
                upLineRightStr = this.editor.editorContent[this.start.line].substr(this.start.ch, this.editor.editorContent[upLine].length - this.start.ch);
                downLineLeftStr = this.editor.editorContent[this.end.line].substr(0, this.end.ch);
            } else {
                upLine = this.end.line;
                downLine = this.start.line;
                upLineRightStr = this.editor.editorContent[this.end.line].substr(this.end.ch, this.editor.editorContent[upLine].length - this.end.ch);
                downLineLeftStr = this.editor.editorContent[this.start.line].substr(0, this.start.ch);
            }
            if (upLine + 1 === downLine) {
                copyStr = upLineRightStr + '\n' + downLineLeftStr;
            } else {
                copyStr = upLineRightStr + '\n' + this.editor.editorContent.slice(upLine + 1, downLine).join('\n') + '\n' + downLineLeftStr;
            }

        }
        //  要把文字真的放到剪貼簿
        this.textInputDom.value = copyStr;
        this.textInputDom.select();
        document.execCommand('copy');
        this.textInputDom.value = '';
    }
    // 要輸入相對於畫布的滑鼠座標
    Selection.prototype.getCaretPos = function (x, y) {
        // 超過目前所擁有的列，就取最後一列
        let offset = this.editor.getOffset();
        let row = Math.floor((-offset.top + y) / this.editor.fontMetric.getHeight());
        if (row > this.editor.editorContent.length - 1) {
            row = this.editor.editorContent.length - 1;
        }
        // 如果超過所在列最右邊的字，就取最右邊的字
        // 要考慮tab佔四個空間
        // 用累計的做法
        let lineStr = this.editor.editorContent[row];
        let halfPos = offset.left;
        let column = -1;
        for (let i = 0; i < lineStr.length; i++) {
            if (i === 0) {
                if (lineStr[i] === '\t') {
                    if (x >= halfPos && x <= halfPos + this.editor.fontMetric.getWidth() * 2) {
                        column = i;
                        break;
                    }
                    halfPos += this.editor.fontMetric.getWidth() * 2;
                } else {
                    if (x >= halfPos && x <= halfPos + this.editor.fontMetric.getWidth() / 2) {
                        column = i;
                        break;
                    }
                    halfPos += this.editor.fontMetric.getWidth() / 2;
                }
            } else {
                let twoPointHalfSum = 0;
                if (lineStr[i] === '\t') {
                    if (lineStr[i - 1] === '\t') {
                        twoPointHalfSum = this.editor.fontMetric.getWidth() * (2 + 2);
                    } else {
                        twoPointHalfSum = this.editor.fontMetric.getWidth() * (2 + 1 / 2.0);
                    }
                } else {
                    if (lineStr[i - 1] === '\t') {
                        twoPointHalfSum = this.editor.fontMetric.getWidth() * (2 + 1 / 2.0);
                    } else {
                        twoPointHalfSum = this.editor.fontMetric.getWidth() * (1 / 2.0 + 1 / 2.0);
                    }
                }
                if (x >= halfPos && x <= halfPos + twoPointHalfSum) {
                    column = i;
                    break;
                }
                halfPos += twoPointHalfSum;
            }
        }
        if (column === -1) {
            column = lineStr.length;
        }

        return {
            line: row,
            ch: column
        };
    }
    Selection.prototype.getMousePos = function (e) {
        let rect = e.target.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        return {
            x: x,
            y: y
        }
    }
    Selection.prototype.mouseClick = function (e) {
        let mousePos = this.getMousePos(e);
        //  偵測在點擊的地方在哪，更改游標位置
        let pos = this.getCaretPos(mousePos.x, mousePos.y);
        this.setPosition(pos.line, pos.ch);
    }

    var Editor = function () {
        this.editor = document.getElementById("canvas-text-editor");
        let canvas = document.getElementById('canvas');
        let textInput = document.getElementById('textInput');
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        var fontSize = 17;
        var fontFamily = 'Courier New';
        // 用baseline
        this.fontMetric = new FontMetrics(fontFamily, fontSize);
        this.getFontMetric = function () {
            return this.fontMetric;
        }
        this.getEl = function () {
            return this.editor;
        }
        this.insertLine = function (text, lineIndex) {
            editorContent.splice(lineIndex, 0, text);
        }
        this.insertText = function (text, lineIndex, chIndex) {
            curStr = editorContent[lineIndex];
            editorContent[lineIndex] = curStr.substr(0, chIndex) + text + curStr.substr(chIndex, curStr.length - chIndex);
        }
        this.getFocus = function () {
            textInput.focus();
            this.focus = true;
            canvas.classList.add('editor-focus');
            selection.caretDiv.style.opacity = '1';
            clearInterval(selection.interval);
            selection.interval = setInterval(selection.blink.bind(selection), selection.blinkInterval);
        }

        this.lostFocus = function () {
            this.focus = false;
            canvas.classList.remove('editor-focus');
            clearInterval(selection.interval);
            selection.caretDiv.style.opacity = '0';
        }

        this.editorContent = [];
        let content = "using namespace std;\n" +
            "int main()\n" +
            "{\n" +
            "\tint month, day;\n" +
            "\tcout << \"Welcome\\n\";\n" +
            "\tcin >> month;\n" +
            "\tcin >> day;\n" +
            "\tsrand(month * day);\n" +
            "\tint prediction;\n" +
            "\tchar ans;\n" +
            "\tcout << \"Weather for today:\\n\";\n" +
            "\tcout << \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\";\n" +
            "\tdo \n" +
            "\t{\n" +
            "\t\tprediction = rand() % 3;\n" +
            "\t\tswitch (prediction)\n" +
            "\t\t{\n" +
            "\t\t\tcase 0:\n" +
            "\t\t\t\tcout << '0';\n" +
            "\t\t\t\tbreak;\n" +
            "\t\t\tcase 1:\n" +
            "\t\t\t\tcout << '1';\n" +
            "\t\t\t\tbreak;\n" +
            "\t\t\tdefault:\n" +
            "\t\t\t\tcout << 'default';\n" +
            "\t\t\n" +
            "\t\t}\n" +
            "\t\t\n" +
            "\t} while (ans == 'y' || and == 'Y');\n" +
            "\treturn 0;";
        let lines = content.split('\n');
        for (let i = 0; i < lines.length; i++) {
            this.editorContent.push(lines[i]);
        }

        // 在此設定畫面的大小，畫布呈現全部或部分的畫面，就由滑桿看不同的部分
        // 要找出所有行中最寬的那一行
        this.getLogestLineLeng = function () {
            let maxLeng = -1;
            for (let i = 0; i < this.editorContent.length; i++) {
                let curLineLeng = 0;
                for (let j = 0; j < this.editorContent[i].length; j++) {
                    if (this.editorContent[i][j] === '\t') {
                        curLineLeng += 4 * this.fontMetric.getWidth();
                    } else {
                        curLineLeng += this.fontMetric.getWidth();
                    }
                }
                if (curLineLeng > maxLeng) {
                    maxLeng = curLineLeng;
                }
            }
            return maxLeng;
        }
        this.updateSliderBar = function () {
            let editor_scrollBar_style = document.querySelector('[data="slider"]');
            editor_scrollBar_style.innerHTML = ".v-slider::-webkit-slider-thumb { width: " + canvas.clientHeight / editor_height * canvas.clientHeight + "px; } .slider::-webkit-slider-thumb { width: " + canvas.clientWidth / editor_width * canvas.clientWidth + "px; }";
        }
        this.getEditorWid = function () {
            let maxLeng = this.getLogestLineLeng();
            if (maxLeng < canvas.clientWidth) {
                return canvas.clientWidth;
            }
            return maxLeng;
        }
        this.getEditorHgt = function () {
            let hgt = this.fontMetric.getHeight() * this.editorContent.length;
            if (hgt < canvas.clientHeight) {
                return canvas.clientHeight;
            }
            return hgt;
        }
        let editor_width = this.getEditorWid();
        let editor_height = this.getEditorHgt();
        this.getOffset = function () {
            let top = -editor_vScrollBar.value / 100.0 * (editor_height - canvas.clientHeight);
            let left = -editor_hScrollBar.value / 100.0 * (editor_width - canvas.clientWidth);
            return {top: top, left: left};
        }

        this.moveSliderThumb = function (moveX, moveY) {
            // 請注意editor_hScrollBar.value是字串
            let oriHValue = parseInt(editor_hScrollBar.value);
            editor_hScrollBar.value = oriHValue + Math.ceil(moveX / (editor_width - canvas.clientWidth) * 100);
            console.log('editor_hScrollBar.value : ' + editor_hScrollBar.value);
            let oriVValue = parseInt(editor_vScrollBar.value);
            editor_vScrollBar.value = oriVValue + Math.ceil(moveY / (editor_height - canvas.clientHeight) * 100);
        }
        //  撰寫能夠檢查caret是否超過邊界的函數
        this.checkCaretOutOfRange = function () {
            let endLine = this.selection.getEnd().line;
            let endCh = this.selection.getEnd().ch;
            let content = this.editorContent[endLine];
            let tabNum = this.calculateTabNum(content, 0, endCh);
            let curX = tabNum * this.fontMetric.getWidth() * 4 + (endCh - tabNum) * this.fontMetric.getWidth();
            let curY = (endLine + 1) * this.fontMetric.getHeight();
            let moveX = curX + this.getOffset().left - canvas.clientWidth;
            if (moveX > 0) {
                this.moveSliderThumb(moveX, 0);
            } else if (moveX < -canvas.clientWidth) {
                this.moveSliderThumb(moveX + canvas.clientWidth - 10, 0);
            }
            let moveY = curY + this.getOffset().top - canvas.clientHeight;
            if (moveY > 0) {
                this.moveSliderThumb(0, moveY);
            } else if (moveY < -canvas.clientHeight + this.fontMetric.getBaseline()) {
                this.moveSliderThumb(0, moveY + canvas.clientHeight - this.fontMetric.getHeight());
            }
            this.selection.updateCursor(endLine, endCh);
        }

        // 繪製時需要使用的文字與樣式資訊
        this.editorContentStyle = [];
        this.EditNotifyType = {
            DELETE: 1,
            CHANGE: 2,
            ADD: 3
        }
        // 根據editorContentStyle繪製有色彩的文字
        this.updateEditorContentStyle = function (editType, range) {
            let sLine = parseInt(range.sLine);
            let eLine = parseInt(range.eLine);
            if (editType === this.EditNotifyType.ADD) {
                // sLine代表從第幾個editorContent為新增的內容
                let pushIndex = sLine;
                if (pushIndex < 0) pushIndex = 0;
                for (let i = sLine; i <= eLine; i++) {
                    let lineColorInfo = this.colorLexerStr(this.editorContent[i]);
                    this.editorContentStyle.splice(pushIndex, 0, lineColorInfo);
                    pushIndex++;
                }
            } else if (editType === this.EditNotifyType.CHANGE) {
                for (let i = sLine; i <= eLine; i++) {
                    this.editorContentStyle[i] = this.colorLexerStr(this.editorContent[i]);
                }
            } else if (editType === this.EditNotifyType.DELETE) {
                this.editorContentStyle.splice(sLine, eLine - sLine + 1);
            }
        }

        this.selection = new Selection(this);
        let selection = this.selection;
        this.focus = false;
        canvas.classList.add('editor-non-focus');
        this.ctx.font = fontSize + 'px ' + fontFamily;
        textInput.onblur = function (e) {
            // 因為滑鼠按到瀏覽器不是頁面的視窗或是其他視窗，導致焦點遺失
            this.lostFocus();
        }.bind(this);

        document.onclick = function (e) {
            // 有時候滑鼠點擊到畫布上，但是e.target會是<div id="canvas-text-editor"></div>，也就是它的母元素
            // 快吐血 = =
            if (e.target === canvas || e.target.id === 'canvas-text-editor') {
                if (this.focus === false) {
                    this.getFocus();
                }
            } else {
                this.lostFocus();
            }
        }.bind(this);

        let canvasMouseDown = false;
        let expandSelection = function (offsetX, offsetY) {
            console.log(this.editorContent[this.selection.getEnd().line].length);
            let oriEndCh = this.selection.getEnd().ch;
            let oriEndLine = this.selection.getEnd().line;
            let curLineLeng = this.editorContent[this.selection.getEnd().line].length;
            if (offsetX === 1) {
                if (oriEndCh < curLineLeng) {
                    this.selection.setEndPos(oriEndLine, oriEndCh + offsetX);
                }
            } else if (offsetX === -1) {
                if (oriEndCh > 0) {
                    this.selection.setEndPos(oriEndLine, oriEndCh + offsetX);
                }
            } else if (offsetY === 1) {
                if (oriEndLine < this.editorContent.length) {
                    this.selection.setEndPos(oriEndLine + offsetY, oriEndCh);
                }
            } else if (offsetY === -1) {
                if (oriEndLine > 0) {
                    this.selection.setEndPos(oriEndLine + offsetY, oriEndCh);
                }
            }
            this.checkCaretOutOfRange();
            this.render();
        }.bind(this);
        let expandSelection_id = null;
        document.onmouseup = function (e) {
            canvasMouseDown = false;
            if (expandSelection_id) {
                clearInterval(expandSelection_id);
                this.getFocus();
            }
        }.bind(this);
        document.addEventListener('mousedown', function (e) {
            canvasMouseDown = true;
            selection.mouseClick(e);
            console.log('document.onmousedown');
            render();
        });

        canvas.onmouseleave = function (e) {
            let mousePos = selection.getMousePos(e);
            if (canvasMouseDown) {
                if (mousePos.x >= canvas.style.left + canvas.clientWidth - 10) {
                    console.log('canvas.onmouseleave ');
                    expandSelection_id = setInterval(function () {
                        expandSelection(1, 0);
                    }, 50);
                } else if (mousePos.x <= canvas.style.left + 10) {
                    console.log('canvas.onmouseleave ');
                    expandSelection_id = setInterval(function () {
                        expandSelection(-1, 0);
                    }, 50);
                } else if (mousePos.y >= canvas.style.top + canvas.clientHeight - 10) {
                    console.log('canvas.onmouseleave ');
                    expandSelection_id = setInterval(function () {
                        expandSelection(0, 1);
                    }, 50);
                } else if (mousePos.y <= canvas.style.top + 10) {
                    console.log('canvas.onmouseleave ');
                    expandSelection_id = setInterval(function () {
                        expandSelection(0, -1);
                    }, 50);
                }
            }
        }.bind(this);

        canvas.onmousemove = function (e) {
            let mousePos = selection.getMousePos(e);
            let curCaretPos = selection.getCaretPos(mousePos.x, mousePos.y);
            //  這時候做的事情很有可能是選取區塊並且滑鼠位置在畫布外，如果是那樣的話就很可能進行游標的移動
            // 設定選取的範圍
            if (canvasMouseDown) {
                if (expandSelection_id) {
                    clearInterval(expandSelection_id);
                }
                selection.setEndPos(curCaretPos.line, curCaretPos.ch);
                selection.updateCursor(curCaretPos.line, curCaretPos.ch);
                render();
            }
        }.bind(this);

        this.calculateTabNum = function (str, sCh, eCh) {
            let tabNum = 0;
            if (eCh < sCh) {
                let temp = eCh;
                eCh = sCh;
                sCh = temp;
            }
            for (let i = sCh; i <= eCh; i++) {
                if (str[i] === '\t') {
                    tabNum += 1;
                }
            }
            return tabNum;
        }

        this.drawSelectionHasTab = function (lineNum, sCh, eCh) {
            let offset = this.getOffset();
            let left = offset.left;
            let top = offset.top;
            let chWid = this.fontMetric.getWidth();
            let chHgt = this.fontMetric.getHeight();
            let curLineStr = this.editorContent[lineNum];
            let caretLeftTabNum = this.calculateTabNum(curLineStr, 0, sCh - 1);
            let caretRightTabNum = this.calculateTabNum(curLineStr, sCh, eCh - 1);
            if (eCh < sCh) {
                caretLeftTabNum = this.calculateTabNum(curLineStr, 0, eCh - 1);
                caretRightTabNum = this.calculateTabNum(curLineStr, eCh, sCh - 1);
            }
            // 包含第一個時，要扣掉第一個tab
            if (sCh === 0 || eCh === 0) {
                if (caretLeftTabNum === 1) {
                    caretLeftTabNum -= 1;
                }
            }
            let addtionalCaretLeftLength = 3 * this.fontMetric.getWidth() * caretLeftTabNum;
            let addtionalCaretRightLength = 3 * this.fontMetric.getWidth() * caretRightTabNum;
            if (eCh < sCh) {
                this.ctx.fillRect(2 + Math.min(sCh, eCh) * chWid + addtionalCaretLeftLength + left, chHgt * lineNum + top, chWid * (Math.abs(sCh - eCh)) + addtionalCaretRightLength, chHgt);

            } else {
                this.ctx.fillRect(2 + Math.min(sCh, eCh) * chWid + addtionalCaretLeftLength + left, chHgt * lineNum + top, chWid * (Math.abs(sCh - eCh)) + addtionalCaretRightLength, chHgt);
            }
        }

        // tab佔四個空間
        this.renderSelection = function (sLine, sCh, eLine, eCh) {
            if (sLine !== eLine || sCh !== eCh) {
                this.ctx.fillStyle = '#c4dbff';
                let chWid = this.fontMetric.getWidth();
                let chHgt = this.fontMetric.getHeight();
                // 多一個tab會比原本多三個寬，用加的修正
                if (sLine === eLine) {
                    this.drawSelectionHasTab(sLine, sCh, eCh);
                } else if (sLine < eLine) {
                    // 吃到右邊到底
                    this.drawSelectionHasTab(sLine, sCh, this.editorContent[sLine].length);
                    for (let i = sLine + 1; i <= eLine - 1; i++) {
                        // 填滿整行
                        this.drawSelectionHasTab(i, 0, this.editorContent[i].length);
                    }
                    this.drawSelectionHasTab(eLine, 0, eCh);
                } else {
                    // 吃到左邊到底
                    this.drawSelectionHasTab(sLine, 0, sCh);
                    for (let i = sLine - 1; i >= eLine + 1; i--) {
                        // 填滿整行
                        this.drawSelectionHasTab(i, 0, this.editorContent[i].length);
                    }
                    this.drawSelectionHasTab(eLine, eCh, this.editorContent[eLine].length);
                }
            }
        }

        function colorInfo(color, str, type) {
            return {color: color, str: str, type: type};
        }

        // 將純文字變成有樣式的儲存形式的lexer
        this.colorLexerStr = function (str) {
            let wordArr = [];
            let s = '';
            for (let i = 0; i < str.length; i++) {
                if (str[i] !== ' ' && str[i] !== '\t') {
                    s += str[i];
                } else {
                    if (s !== '') {
                        wordArr.push(s);
                        s = '';
                        wordArr.push(str[i]);
                    } else {
                        wordArr.push(str[i]);
                    }
                }
            }
            wordArr.push(s);

            // wordArr會有一些word是「break;』，也就是結尾帶著標點符號
            // 要把它切開
            let symbolArr = [':', ';'];
            for (let i = 0; i < wordArr.length; i++) {
                let word = wordArr[i];
                if (matchOne(word[word.length - 1], symbolArr)) {
                    wordArr.splice(i, 1, word.substr(0, word.length - 1), word.substr(word.length - 1, 1));
                    i += 1;
                }
            }

            let wordStyleArr = [];

            function matchOne(word, arr) {
                for (let i = 0; i < arr.length; i++) {
                    if (word === arr[i]) {
                        return true;
                    }
                }
                return false;
            }

            // string中間可能有空白因此被切割相異word
            function isString(wordArr, SWordIndex) {
                let matchEndIndex = -1;
                for (let i = SWordIndex; i < wordArr.length; i++) {
                    if (wordArr[SWordIndex].length > 0 && wordArr[i].length > 0) {
                        if (wordArr[SWordIndex][0] === '\'' && wordArr[i][wordArr[i].length - 1] === '\'') {
                            matchEndIndex = i;
                            break;
                        }
                        if (wordArr[SWordIndex][0] === '\"' && wordArr[i][wordArr[i].length - 1] === '\"') {
                            matchEndIndex = i;
                            break;
                        }
                    }
                }
                return matchEndIndex;
            }


            let instructionWordArr = ['and', 'break', 'case', 'catch', 'continue', 'delete', 'new', 'using', 'namespace', 'while', 'return', 'default', 'do', 'switch', 'default'];
            let instructionWordColor = '#0000FF';
            let instructionType = 'bold';
            let typeWordArr = ['bool', 'char', 'const', 'double', 'enum', 'float', 'int', 'void'];
            let typeWordColor = '#8000FF';
            let typeWordType = '';
            let stringColor = '#808080';
            let stringType = '';
            let numberColor = '#FF8000';
            let numberType = '';
            // 設定特定關鍵字的顏色顏色資訊
            // 辨識數字和字串並且設定他們的顏色
            for (let i = 0; i < wordArr.length; i++) {
                if (matchOne(wordArr[i], instructionWordArr)) {
                    wordStyleArr.push(colorInfo(instructionWordColor, wordArr[i], instructionType));
                } else if (matchOne(wordArr[i], typeWordArr)) {
                    wordStyleArr.push(colorInfo(typeWordColor, wordArr[i], typeWordType));
                } else if (isString(wordArr, i) !== -1) { // 辨識字串
                    let endIndex = isString(wordArr, i);
                    for (let j = i; j <= endIndex; j++) {
                        wordStyleArr.push(colorInfo(stringColor, wordArr[j], stringType));
                    }
                    i = endIndex;
                } else if (!isNaN(parseInt(wordArr[i])) || !isNaN(parseFloat(wordArr[i]))) {
                    wordStyleArr.push(colorInfo(numberColor, wordArr[i], numberType));
                } else {
                    wordStyleArr.push(colorInfo('#000000', wordArr[i], ''));
                }
            }
            return wordStyleArr;
        }
        this.colorLexerArr = function (contentArr) {
            let contentStyleArr = [];
            for (let i = 0; i < contentArr.length; i++) {
                contentStyleArr.push(this.colorLexerStr(contentArr[i]));
            }
            return contentStyleArr;
        }


        // 要根據editorContentStyle繪製 以及 遇到tab要當作四個空格來畫
        // 繪製文字和選取的區塊，根據editorContentStyle
        this.render = function () {
            // 清空畫面
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            let offset = this.getOffset();
            let left = offset.left;
            let top = offset.top;
            // 繪製選取的文字區塊
            this.renderSelection(selection.getStart().line, selection.getStart().ch, selection.getEnd().line, selection.getEnd().ch);

            // 繪製文字
            this.ctx.fillStyle = 'black';
            for (let i = 0; i < this.editorContentStyle.length; i++) {
                let posX = 0;
                for (let j = 0; j < this.editorContentStyle[i].length; j++) {
                    let content = this.editorContentStyle[i][j].str;
                    if (content === '\t') {
                        this.ctx.fillText('    ', 2 + posX + left, this.fontMetric.getBaseline() + this.fontMetric.getHeight() * i + top);
                        posX += this.fontMetric.getWidth() * 4;
                    } else {
                        this.ctx.fillStyle = this.editorContentStyle[i][j].color;
                        if (this.editorContentStyle[i][j].type === 'bold') {
                            this.ctx.font = 'bold ' + fontSize + 'px ' + fontFamily;
                        } else {
                            this.ctx.font = fontSize + 'px ' + fontFamily;
                        }
                        this.ctx.fillText(content, 2 + posX + left, this.fontMetric.getBaseline() + this.fontMetric.getHeight() * i + top);
                        posX += this.fontMetric.getWidth() * content.length;
                    }
                }
            }
        }


        this.editorContentStyle = this.colorLexerArr(this.editorContent);
        this.selection.setPosition(2, 3);
        this.render();
        let editorContent = this.editorContent;
        let render = this.render.bind(this);
        textInput.oninput = function (e) {
            if (e.inputType === 'insertFromPaste') {
                // 如果有選取文字，要把選取的刪掉，因為是覆蓋上去
                if (selection.isSelection()) {
                    selection.deleteSelection();
                }
                // 要檢查是否有換行符號
                let lines = textInput.value.split('\n');
                let curLine = selection.getStart().line;
                let curCh = selection.getStart().ch;
                if (lines.length === 1) {
                    this.insertText(textInput.value, curLine, curCh);
                    selection.setPosition(curLine, curCh + textInput.value.length);
                } else {
                    let leftStr = editorContent[curLine].substr(0, curCh);
                    let rightStr = editorContent[curLine].substr(curCh, editorContent[curLine].length - curCh);
                    editorContent[curLine] = leftStr + lines[0];
                    for (let i = 1; i < lines.length; i++) {
                        this.insertLine(lines[i], curLine + i);
                    }
                    editorContent[curLine + lines.length - 1] += rightStr;
                    selection.setPosition(curLine + lines.length - 1, editorContent[curLine + lines.length - 1].length);
                }

                // 送出改變通知
                this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {
                    sLine: curLine,
                    eLine: curLine
                });
                if (lines.length > 1) {
                    this.updateEditorContentStyle(this.EditNotifyType.ADD, {
                        sLine: curLine + 1,
                        eLine: parseInt(curLine) + (lines.length) - 1
                    });
                }
                render();
            }

        }.bind(this);
        document.onkeydown = function (e) {
            if (this.focus === true) {
                // 要特別看待一些特殊按鍵像是Enter、上下左右方向鍵等
                if (e.shiftKey === true && e.key === 'ArrowLeft') {
                    // 用鍵盤選取文字
                    selection.selectLeft();
                } else if (e.shiftKey === true && e.key === 'ArrowRight') {
                    // 用鍵盤選取文字
                    selection.selectRight();
                } else if (e.shiftKey === true && e.key === 'ArrowUp') {
                    // 用鍵盤選取文字
                    selection.selectUp();
                } else if (e.shiftKey === true && e.key === 'ArrowDown') {
                    // 用鍵盤選取文字
                    selection.selectDown();
                } else if (e.ctrlKey === true && e.key === 'c') { // ctrl + c 複製
                    selection.copySelection();
                } else if (e.ctrlKey === true && e.key === 'v') { // ctrl + v 貼上
                    // 要清掉 textarea 中的文字
                    textInput.value = '';
                } else if (e.key === 'ArrowLeft') {
                    selection.moveLeft();
                } else if (e.key === 'ArrowRight') {
                    selection.moveRight();
                } else if (e.key === 'ArrowUp') {
                    selection.moveUp();
                } else if (e.key === 'ArrowDown') {
                    selection.moveDown();
                } else if (e.key === 'Enter') {
                    if (selection.isSelection()) {
                        selection.deleteSelection();
                    }
                    let selStart = selection.getStart();
                    let leftStr = editorContent[selStart.line].substr(0, selStart.ch);
                    let rightStr = editorContent[selStart.line].substr(selStart.ch, editorContent[selStart.line].length - selStart.ch);
                    editorContent[selStart.line] = leftStr;
                    let curLine = selStart.line;
                    this.insertLine(rightStr, selection.getStart().line + 1);
                    this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {
                        sLine: curLine,
                        eLine: curLine
                    });
                    this.updateEditorContentStyle(this.EditNotifyType.ADD, {
                        sLine: curLine + 1,
                        eLine: curLine + 1
                    });
                    selection.setPosition(selStart.line + 1, rightStr.length);
                    textInput.value = '';
                } else if (e.key === 'Backspace') {
                    if (!selection.isSelection()) {
                        let selStart = selection.getStart();
                        let curLine = selStart.line;
                        let curCh = selStart.ch;
                        if (curCh > 0) {
                            editorContent[curLine] = editorContent[curLine].substr(0, curCh - 1) + editorContent[curLine].substr(curCh, editorContent[curLine].length);
                            selection.addChs(-1);
                            // 送出通知
                            this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {sLine: curLine, eLine: curLine});
                        } else if (curLine !== 0) {
                            let content = editorContent[curLine];
                            editorContent.splice(curLine, 1);
                            editorContent[curLine - 1] = editorContent[curLine - 1].concat(content);
                            selection.setPosition(curLine - 1, editorContent[curLine - 1].length);
                            // 送出通知
                            this.updateEditorContentStyle(this.EditNotifyType.DELETE, {sLine: curLine, eLine: curLine});
                            this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {
                                sLine: curLine - 1,
                                eLine: curLine - 1
                            });
                        }
                    } else {
                        selection.deleteSelection();
                    }

                } else if (e.key === 'Tab') {
                    let start = selection.getStart();
                    let curLine = start.line;
                    let curCh = start.ch;
                    editorContent[curLine] = editorContent[curLine].substr(0, curCh) + '\t' + editorContent[curLine].substr(curCh);
                    this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {sLine: curLine, eLine: curLine});
                    selection.addChs(1);
                    this.getFocus();

                } else if (e.key.length === 1) {
                    if (selection.isSelection()) {
                        selection.deleteSelection();
                    }
                    let start = selection.getStart();
                    let curLine = start.line;
                    let curCh = start.ch;
                    editorContent[curLine] = editorContent[curLine].substr(0, curCh) + e.key + editorContent[curLine].substr(curCh);
                    selection.addChs(1);
                    this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {sLine: curLine, eLine: curLine});
                    textInput.value = '';
                }
                // 可能會因為刪掉或新增而要刷新editor_height, editor_width和滑桿thumb的大小
                editor_height = this.getEditorHgt();
                editor_width = this.getEditorWid();
                this.updateSliderBar();
                this.checkCaretOutOfRange();
                render();
                console.log('haha');
                // 如果焦點在canvas上，也就是編輯器上，就讓編輯器吃掉鍵盤訊號，不要讓鍵盤訊號影響到其他的地方
                if (e.ctrlKey !== true && e.key !== 'v') {
                    e.preventDefault();
                }
            }
        }.bind(this);
        // 下面是根據滑桿重新繪製的部分

        this.handleCanvasSizeChange = function () {
            // 根據畫布大小，調整水平和垂直滑桿的長度
            editor_hScrollBar.style.width = canvas.clientWidth + 'px';
            editor_vScrollBar.style.width = canvas.clientHeight + 'px';
            editor_vScrollBar.style.top = canvas.clientHeight / 2 - 12 + 'px';
            editor_vScrollBar.style.left = -editor_vScrollBar.clientWidth / 2 + canvas.clientWidth + 12 + 'px';

            // 根據實際編輯區塊的大小與畫布大小，決定滑桿上的按鈕長度
            let editor_scrollBar_style = document.querySelector('[data="slider"]');
            editor_scrollBar_style.innerHTML = ".v-slider::-webkit-slider-thumb { width: " + canvas.clientHeight / editor_height * canvas.clientHeight + "px; } .slider::-webkit-slider-thumb { width: " + canvas.clientWidth / editor_width * canvas.clientWidth + "px; }";
        }
        let oriRatio = canvas.width/parseInt(canvas.style.width);
        console.log("oriRatio : "+ oriRatio);

        // todo: 改變畫布的寬度
        function increaseCanvasWid() {
            let widStr = (parseInt(canvas.style.width) + 10)*oriRatio + 'px';
            canvas.width += 10;
            canvas.style.width = widStr;
            let hgtStr = (parseInt(canvas.style.height) + 10)*oriRatio + 'px';
            canvas.height += 10;
            canvas.style.height = hgtStr;
            editor.handleCanvasSizeChange();
        }

        document.getElementById('increase-btn').onclick = increaseCanvasWid;

        this.handleCanvasSizeChange();

        render();
        // 當拉動滑桿時要重新繪製
        editor_vScrollBar.oninput = function () {
            // 重新繪製
            // 繪製東西的位置要根據滑桿做調整
            render();
        }.bind(this);
        editor_hScrollBar.oninput = function () {
            // 重新繪製
            console.log(editor_hScrollBar.value);
            render();
        }.bind(this);
    }
</script>

<script>
    var editor = new Editor();

</script>
</body>
</html>