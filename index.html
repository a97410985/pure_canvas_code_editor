<!--  讓editorContent和editorContentStyle的內容同步 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>editor v8</title>
    <style>
        .editor-non-focus {
            border: black 1px solid;
        }

        .editor-focus {
            border: #ff7f11 1px solid;
        }
    </style>
</head>
<body>
<div id="canvas-text-editor">
    <canvas id="canvas" width="500" height="500"></canvas>
    <textarea id="textInput" style="position: absolute"></textarea>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
<script>
    WebFont.load({
        google: {
            families: ['Courier New']
        }
    });
</script>
<script>
    /**
     * A simple wrapper for system fonts to provide
     * @param {String} family Font Family (same as in CSS)
     * @param {Number} size Size in px
     * @constructor
     */
    var FontMetrics = function (family, size) {
        this._family = family || (family = "Courier New, Courier, monospace");
        this._size = parseInt(size) || (size = 12);

        // Preparing container
        var line = document.createElement('div'),
            body = document.body;
        line.style.position = 'absolute';
        line.style.whiteSpace = 'nowrap';
        line.style.font = size + 'px ' + family;
        body.appendChild(line);

        // Now we can measure width and height of the letter
        var text = 'mmmmmmmmmm';
        line.innerHTML = text;
        this._width = line.offsetWidth / text.length;
        this._height = line.offsetHeight;

        // Now creating 1px sized item that will be aligned to baseline
        // to calculate baseline shift
        var span = document.createElement('span');
        span.style.display = 'inline-block';
        span.style.overflow = 'hidden';
        span.style.width = '1px';
        span.style.height = '1px';
        line.appendChild(span);

        // Baseline is important for positioning text on canvas
        this._baseline = span.offsetTop + span.offsetHeight;
        line.remove();
    };


    /**
     * Returns font family
     * @return {String}
     */
    FontMetrics.prototype.getFamily = function () {
        return this._family;
    };

    /**
     * Returns font family
     * @return {Number}
     */
    FontMetrics.prototype.getSize = function () {
        return this._size;
    };

    /**
     * Returns line height in px
     * @return {Number}
     */
    FontMetrics.prototype.getHeight = function () {
        return this._height;
    };

    /**
     * Returns line height in px
     * @return {Number}
     */
    FontMetrics.prototype.getWidth = function () {
        return this._width;
    };

    /**
     * Returns line height in px
     * @return {Number}
     */
    FontMetrics.prototype.getBaseline = function () {
        return this._baseline;
    };
</script>

<script>
    var Selection = function (editor) {
        this.editor = editor;
        this.textInputDom = document.getElementById('textInput');
        this.start = {
            line: 0,
            ch: 0
        }
        this.end = {
            line: 0,
            ch: 0
        }
        this.blinkInterval = 500;
        this.caretDiv = document.createElement('div');
        this.caretDiv.style.position = 'absolute';
        this.caretDiv.style.width = '1px';
        this.caretDiv.style.height = this.editor.getFontMetric().getHeight() + 'px';
        this.caretDiv.style.background = 'black';
        this.editor.getEl().appendChild(this.caretDiv);
        this.blink = function () {
            if (this.caretDiv.style.opacity === '1') {
                this.caretDiv.style.opacity = '0';
            } else {
                this.caretDiv.style.opacity = '1';
            }
        }
    }
    Selection.prototype.getStart = function () {
        return this.start;
    }
    Selection.prototype.getEnd = function () {
        return this.end;
    }
    Selection.prototype.updateCursor = function (line, ch) {
        let lineContent = this.editor.editorContent[line];
        let contentWid = this.editor.ctx.measureText(lineContent.substr(0, ch)).width;
        this.caretDiv.style.left = (this.editor.canvas.offsetLeft + contentWid + 1).toString() + 'px';
        this.caretDiv.style.top = (this.editor.canvas.offsetTop + line * this.editor.getFontMetric().getHeight()).toString() + 'px';
        if (this.editor.focus) {
            this.caretDiv.style.opacity = '1';
            clearInterval(this.interval);
            this.interval = setInterval(this.blink.bind(this), this.blinkInterval);
        } else {
            this.caretDiv.style.opacity = '0';
        }
    }

    Selection.prototype.addChs = function (num) {
        this.start.ch += num;
        this.end.ch += num;
        this.updateCursor(this.start.line, this.start.ch);
    }
    Selection.prototype.setStartPos = function (line, ch) {
        this.start.line = line;
        this.start.ch = ch;
    }
    Selection.prototype.setEndPos = function (line, ch) {
        this.end.line = line;
        this.end.ch = ch;
    }
    Selection.prototype.setPosition = function (line, ch) {
        this.setStartPos(line, ch);
        this.setEndPos(line, ch);
        this.updateCursor(line, ch);
    }
    Selection.prototype.moveLeft = function () {
        // 要先清除目前選取的東西
        let curCh = this.end.ch;
        let curLine = this.end.line;
        if (curCh > 0) {
            curCh--;
        } else {
            if (curLine > 0) {
                curLine--;
                curCh = this.editor.editorContent[curLine].length;
            }
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.moveRight = function () {
        let curCh = this.end.ch;
        let curLine = this.end.line;
        let curLineStr = this.editor.editorContent[curLine];
        if (curCh > curLineStr.length - 1) {
            if (curLine < this.editor.editorContent.length - 1) {
                curLine++;
                curCh = 0;
            }
        } else {
            curCh++;
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.moveUp = function () {
        let curCh = this.end.ch;
        let curLine = this.end.line;
        if (curLine > 0) {
            curLine--;
            let curLineStr = this.editor.editorContent[curLine];
            if (curCh > curLineStr.length) {
                curCh = curLineStr.length;
            }
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.moveDown = function () {
        let curCh = this.end.ch;
        let curLine = this.end.line;
        if (curLine < this.editor.editorContent.length - 1) {
            curLine++;
            let curLineStr = this.editor.editorContent[curLine];
            if (curCh > curLineStr.length) {
                curCh = curLineStr.length;
            }
        }
        this.setPosition(curLine, curCh);
    }
    Selection.prototype.selectLeft = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveLeft();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.selectRight = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveRight();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.selectUp = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveUp();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.selectDown = function () {
        let oriSLine = this.start.line;
        let oriSCh = this.start.ch;
        this.moveDown();
        this.start.line = oriSLine;
        this.start.ch = oriSCh;
    }
    Selection.prototype.deleteSelection = function () {
        console.log('sLine'+this.start.line+" ; eLine"+this.end.line);
        if (this.start.line === this.end.line) {
            let content = this.editor.editorContent[this.start.line];
            let left = Math.min(this.start.ch, this.end.ch);
            let right = Math.max(this.start.ch, this.end.ch);
            this.editor.editorContent[this.start.line] = content.substr(0, left) + content.substr(right, content.length - right);
            this.setPosition(this.start.line, left);
            // 送出通知
            this.editor.updateEditorContentStyle(this.editor.EditNotifyType.CHANGE, {
                sLine: this.start.line,
                eLine: this.end.line
            });
        } else {
            // 一定有一行在比較下面，我叫他downRightStr
            let downRightStr = '';
            let startLineStr = this.editor.editorContent[this.start.line];
            let endLineStr = this.editor.editorContent[this.end.line];
            console.log('sLine'+this.start.line+" ; eLine"+this.end.line);

            if (this.start.line < this.end.line) {
                downRightStr = endLineStr.substr(this.end.ch, endLineStr.length - this.end.ch);
                this.editor.editorContent.splice(this.start.line + 1, this.end.line - this.start.line);
                this.editor.editorContent[this.start.line] = startLineStr.substr(0, this.start.ch) + downRightStr;
                // 送出通知
                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.DELETE, {
                    sLine: this.start.line + 1,
                    eLine: this.end.line
                });

                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.CHANGE, {
                    sLine: this.start.line,
                    eLine: this.start.line
                });
                this.setPosition(this.start.line, this.start.ch);
            } else {
                downRightStr = startLineStr.substr(this.start.ch, startLineStr.length - this.start.ch);
                this.editor.editorContent.splice(this.end.line + 1, this.start.line - this.end.line);
                this.editor.editorContent[this.end.line] = endLineStr.substr(0, this.end.ch) + downRightStr;
                // 送出通知
                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.DELETE, {
                    sLine: this.end.line + 1,
                    eLine: this.start.line
                });

                this.editor.updateEditorContentStyle(this.editor.EditNotifyType.CHANGE, {
                    sLine: this.end.line,
                    eLine: this.end.line
                });
                this.setPosition(this.end.line, this.end.ch);
            }

        }
    }
    Selection.prototype.isSelection = function () {
        return !(this.start.line === this.end.line && this.start.ch === this.end.ch);
    }
    Selection.prototype.copySelection = function () {
        let copyStr = '';
        if (this.start.line === this.end.line) {
            let min = Math.min(this.start.ch, this.end.ch);
            let max = Math.max(this.start.ch, this.end.ch);
            copyStr = this.editor.editorContent[this.start.line].substr(min, max - min);
        } else {
            let upLine = 0;
            let downLine = 0;
            let upLineRightStr = '';
            let downLineLeftStr = '';
            if (this.start.line < this.end.line) {
                upLine = this.start.line;
                downLine = this.end.line;
                upLineRightStr = this.editor.editorContent[this.start.line].substr(this.start.ch, this.editor.editorContent[upLine].length - this.start.ch);
                downLineLeftStr = this.editor.editorContent[this.end.line].substr(0, this.end.ch);
            } else {
                upLine = this.end.line;
                downLine = this.start.line;
                upLineRightStr = this.editor.editorContent[this.end.line].substr(this.end.ch, this.editor.editorContent[upLine].length - this.end.ch);
                downLineLeftStr = this.editor.editorContent[this.start.line].substr(0, this.start.ch);
            }
            if (upLine + 1 === downLine) {
                copyStr = upLineRightStr + '\n' + downLineLeftStr;
            } else {
                copyStr = upLineRightStr + '\n' + this.editor.editorContent.slice(upLine + 1, downLine).join('\n') + '\n' + downLineLeftStr;
            }

        }
        console.log('copy: ' + copyStr);
        //  要把文字真的放到剪貼簿
        this.textInputDom.value = copyStr;
        this.textInputDom.select();
        document.execCommand('copy');
        this.textInputDom.value = '';
    }
    // 要輸入相對於畫布的滑鼠座標
    Selection.prototype.getCaretPos = function (x, y) {
        // 超過目前所擁有的列，就取最後一列
        let row = Math.floor(y / this.editor.fontMetric.getHeight());
        if (row > this.editor.editorContent.length - 1) {
            row = this.editor.editorContent.length - 1;
        }
        // 如果超過所在列最右邊的字，就取最右邊的字
        let column = Math.floor((x / (this.editor.fontMetric.getWidth() / 2.0) + 1) / 2);
        if (column > this.editor.editorContent[row].length) {
            column = this.editor.editorContent[row].length;
        }
        return {
            line: row,
            ch: column
        };
    }
    Selection.prototype.getMousePos = function (e) {
        let rect = e.target.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        return {
            x: x,
            y: y
        }
    }
    Selection.prototype.mouseClick = function (e) {
        let mousePos = this.getMousePos(e);
        //  偵測在點擊的地方在哪，更改游標位置
        let pos = this.getCaretPos(mousePos.x, mousePos.y);
        this.setPosition(pos.line, pos.ch);
    }

    var Editor = function () {
        this.editor = document.getElementById("canvas-text-editor");
        let canvas = document.getElementById('canvas');
        let textInput = document.getElementById('textInput');
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        var fontSize = 20;
        var fontFamily = 'Courier New';
        // 用baseline
        this.fontMetric = new FontMetrics(fontFamily, fontSize);
        this.getFontMetric = function () {
            return this.fontMetric;
        }
        this.getEl = function () {
            return this.editor;
        }
        this.insertLine = function (text, lineIndex) {
            editorContent.splice(lineIndex, 0, text);
        }
        this.insertText = function (text, lineIndex, chIndex) {
            curStr = editorContent[lineIndex];
            editorContent[lineIndex] = curStr.substr(0, chIndex) + text + curStr.substr(chIndex, curStr.length - chIndex);
        }
        this.getFocus = function () {
            textInput.focus();
            this.focus = true;
            canvas.classList.add('editor-focus');
            selection.caretDiv.style.opacity = '1';
            selection.interval = setInterval(selection.blink.bind(selection), selection.blinkInterval);
        }

        this.lostFocus = function () {
            this.focus = false;
            canvas.classList.remove('editor-focus');
            clearInterval(selection.interval);
            selection.caretDiv.style.opacity = '0';
        }

        // 繪製時需要使用的文字與樣式資訊
        this.editorContentStyle = [];
        this.EditNotifyType = {
            DELETE: 1,
            CHANGE: 2,
            ADD: 3
        }
        this.updateEditorContentStyle = function (editType, range) {
            let sLine = parseInt(range.sLine);
            let eLine = parseInt(range.eLine);
            if (editType === this.EditNotifyType.ADD) {
                console.log("add");
                // sLine代表從第幾個editorContent為新增的內容
                let pushIndex = sLine;
                if (pushIndex < 0) pushIndex = 0;
                for (let i = sLine; i <= eLine; i++) {
                    this.editorContentStyle.splice(pushIndex, 0, this.editorContent[i]);
                    console.log("add line : " + pushIndex);
                    pushIndex++;
                }
            } else if (editType === this.EditNotifyType.CHANGE) {
                console.log("change");
                for (let i = sLine; i <= eLine; i++) {
                    this.editorContentStyle[i] = this.editorContent[i];
                    console.log("change line : " + i);
                }
            } else if (editType === this.EditNotifyType.DELETE) {
                console.log("delete");
                this.editorContentStyle.splice(sLine, eLine - sLine+1);
            }
            console.log('editorContentStyle : '+this.editorContentStyle);
            console.log('editorContent : '+this.editorContent);
        }

        this.selection = new Selection(this);
        let selection = this.selection;
        this.focus = false;
        canvas.classList.add('editor-non-focus');
        this.ctx.font = fontSize + 'px ' + fontFamily;
        textInput.onblur = function (e) {
            // 因為滑鼠按到瀏覽器不是頁面的視窗或是其他視窗，導致焦點遺失
            this.lostFocus();
        }.bind(this);

        document.onclick = function (e) {
            if (e.target === canvas) {
                if (this.focus === false) {
                    this.getFocus();
                }
            } else {
                this.lostFocus();
            }
        }.bind(this);


        let canvasMouseUp = false;
        let canvasMouseDown = false;
        document.onmouseup = function (e) {
            canvasMouseUp = true;
        }.bind(this);
        canvas.onmousedown = function (e) {
            canvasMouseDown = true;
            selection.mouseClick(e);
            render();
        }.bind(this);
        canvas.onmousemove = function (e) {
            let sLine = selection.getStart().line;
            let sCh = selection.getStart().ch;
            let mousePos = selection.getMousePos(e);
            let mouseUpCaretPos = selection.getCaretPos(mousePos.x, mousePos.y);
            // t設定選取的範圍
            if (canvasMouseDown) {
                selection.setEndPos(mouseUpCaretPos.line, mouseUpCaretPos.ch);
                selection.updateCursor(mouseUpCaretPos.line, mouseUpCaretPos.ch);
                render();
            }
            if (canvasMouseDown && canvasMouseUp) {
                canvasMouseDown = false;
                canvasMouseUp = false;
            }

        }.bind(this);

        this.renderSelection = function (sLine, sCh, eLine, eCh) {
            if (sLine !== eLine || sCh !== eCh) {
                this.ctx.fillStyle = '#c4dbff';
                let chWid = this.fontMetric.getWidth();
                let chHgt = this.fontMetric.getHeight();
                if (sLine === eLine) {
                    this.ctx.fillRect(2 + Math.min(sCh, eCh) * chWid, chHgt * sLine, chWid * (Math.abs(sCh - eCh)), chHgt);
                } else if (sLine < eLine) {
                    // 吃到右邊到底
                    this.ctx.fillRect(2 + sCh * chWid, chHgt * sLine, chWid * (this.editorContent[sLine].length - sCh), chHgt);
                    for (let i = sLine + 1; i <= eLine - 1; i++) {
                        // 填滿整行
                        this.ctx.fillRect(2, chHgt * i, chWid * this.editorContent[i].length, chHgt);
                    }
                    this.ctx.fillRect(2, chHgt * eLine, chWid * eCh, chHgt);
                } else {
                    // 吃到左邊到底
                    this.ctx.fillRect(2, chHgt * sLine, sCh * chWid, chHgt);
                    for (let i = sLine - 1; i >= eLine + 1; i--) {
                        // 填滿整行
                        this.ctx.fillRect(2, chHgt * i, chWid * this.editorContent[i].length, chHgt);
                    }
                    this.ctx.fillRect(2 + eCh * chWid, chHgt * eLine, chWid * (this.editorContent[eLine].length - eCh), chHgt);
                }
            }
        }
        // 繪製文字和選取的區塊
        this.render = function () {
            // 清空畫面
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // 繪製選取的文字區塊
            this.renderSelection(selection.getStart().line, selection.getStart().ch, selection.getEnd().line, selection.getEnd().ch);

            // 繪製文字
            this.ctx.fillStyle = 'black';
            for (let i = 0; i < this.editorContent.length; i++) {
                this.ctx.fillText(this.editorContent[i], 2, this.fontMetric.getBaseline() + this.fontMetric.getHeight() * i)
            }
        }

        this.editorContent = [];
        this.editorContent.push("a   aaaaa");
        this.editorContent.push("bbbbbbbb");
        this.editorContent.push("ccccccccc");
        this.editorContent.push("ddddddddddd");
        this.editorContentStyle.push("aaaaaa");
        this.editorContentStyle.push("bbbbbbbb");
        this.editorContentStyle.push("ccccccccc");
        this.editorContentStyle.push("ddddddddddd");
        this.selection.setPosition(2, 3);
        this.render();
        let editorContent = this.editorContent;
        let render = this.render.bind(this);
        textInput.oninput = function (e) {
            if (e.inputType === 'insertFromPaste') {
                // 如果有選取文字，要把選取的刪掉，因為是覆蓋上去
                if (selection.isSelection()) {
                    selection.deleteSelection();
                }
                // 要檢查是否有換行符號
                let lines = textInput.value.split('\n');
                let curLine = selection.getStart().line;
                let curCh = selection.getStart().ch;
                if (lines.length === 1) {
                    this.insertText(textInput.value, curLine, curCh);
                    selection.setPosition(curLine, curCh + textInput.value.length);
                } else {
                    let leftStr = editorContent[curLine].substr(0, curCh);
                    let rightStr = editorContent[curLine].substr(curCh, editorContent[curLine].length - curCh);
                    editorContent[curLine] = leftStr + lines[0];
                    for (let i = 1; i < lines.length; i++) {
                        this.insertLine(lines[i], curLine + i);
                    }
                    editorContent[curLine + lines.length - 1] += rightStr;
                    selection.setPosition(curLine + lines.length - 1, editorContent[curLine + lines.length - 1].length);
                }
                // 送出改變通知
                this.updateEditorContentStyle(EditNotifyType.CHANGE, {
                    sLine: curLine,
                    eLine: curLine
                });
                if (lines.length > 1) {
                    this.updateEditorContentStyle(EditNotifyType.ADD, {
                        sLine: curLine + 1,
                        eLine: parseInt(curLine) + (lines.length) - 1
                    });
                }
                console.log(this.editorContent.toString() === this.editorContentStyle.toString());
                render();
            }

        }.bind(this);
        document.onkeydown = function (e) {
            if (this.focus === true) {
                // 要特別看待一些特殊按鍵像是Enter、上下左右方向鍵等
                if (e.shiftKey === true && e.key === 'ArrowLeft') {
                    // 用鍵盤選取文字
                    selection.selectLeft();
                } else if (e.shiftKey === true && e.key === 'ArrowRight') {
                    // 用鍵盤選取文字
                    selection.selectRight();
                } else if (e.shiftKey === true && e.key === 'ArrowUp') {
                    // 用鍵盤選取文字
                    selection.selectUp();
                } else if (e.shiftKey === true && e.key === 'ArrowDown') {
                    // 用鍵盤選取文字
                    selection.selectDown();
                } else if (e.ctrlKey === true && e.key === 'c') { // ctrl + c 複製
                    selection.copySelection();
                } else if (e.ctrlKey === true && e.key === 'v') { // ctrl + v 貼上
                    // 要清掉 textarea 中的文字
                    textInput.value = '';
                } else if (e.key === 'ArrowLeft') {
                    selection.moveLeft();
                } else if (e.key === 'ArrowRight') {
                    selection.moveRight();
                } else if (e.key === 'ArrowUp') {
                    selection.moveUp();
                } else if (e.key === 'ArrowDown') {
                    selection.moveDown();
                } else if (e.key === 'Enter') {
                    if (selection.isSelection()) {
                        selection.deleteSelection();
                    }
                    let selStart = selection.getStart();
                    let leftStr = editorContent[selStart.line].substr(0, selStart.ch);
                    let rightStr = editorContent[selStart.line].substr(selStart.ch, editorContent[selStart.line].length - selStart.ch);
                    editorContent[selStart.line] = leftStr;
                    this.insertLine(rightStr, selection.getStart().line + 1);
                    selection.setPosition(selStart.line + 1, rightStr.length);
                    textInput.value = '';
                } else if (e.key === 'Backspace') {
                    if (!selection.isSelection()) {
                        let selStart = selection.getStart();
                        let curLine = selStart.line;
                        let curCh = selStart.ch;
                        if (curCh > 0) {
                            editorContent[curLine] = editorContent[curLine].substr(0, curCh - 1) + editorContent[curLine].substr(curCh, editorContent[curLine].length);
                            selection.addChs(-1);
                            // 送出通知
                            this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {sLine:curLine, eLine:curLine});
                        } else if (curLine !== 0) {
                            let content = editorContent[curLine];
                            editorContent.splice(curLine, 1);
                            editorContent[curLine - 1] = editorContent[curLine - 1].concat(content);
                            selection.setPosition(curLine - 1, editorContent[curLine - 1].length);
                            // 送出通知
                            this.updateEditorContentStyle(this.EditNotifyType.DELETE, {sLine:curLine, eLine:curLine});
                            this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {sLine:curLine-1, eLine:curLine-1});
                        }
                    } else {
                        selection.deleteSelection();
                    }
                } else if (e.key.length === 1) {
                    if (selection.isSelection()) {
                        selection.deleteSelection();
                    }
                    let start = selection.getStart();
                    let curLine = start.line;
                    let curCh = start.ch;
                    editorContent[curLine] = editorContent[curLine].substr(0, curCh) + e.key + editorContent[curLine].substr(curCh);
                    selection.addChs(1);
                    this.updateEditorContentStyle(this.EditNotifyType.CHANGE, {sLine: curLine, eLine: curLine});
                    console.log(this.editorContent.toString() === this.editorContentStyle.toString());
                    textInput.value = '';
                }
                render();
            }
        }.bind(this);

    }
</script>

<script>
    var editor = new Editor();

</script>
</body>
</html>